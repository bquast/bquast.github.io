---
layout: post
title: "Hand Coding Instumental Vairables"
tags: [R, hand coding, linear model, lm, iv, instumental variables, 2sls, tsls]
permalink: handcoding-instrumental-variables
---

In a previous post we discussed the [linear model](/handcoding-lm)
and how to write a [function that performs a linear regression](/handcoding-lm-function).
In this post we will use that linear model function to perform a [Two-Stage Least Squares estimation].
This estimation allows us to [...]

[Recall](/handcoding-lm-function) that we built the follow linear model function.

```{r}
ols <- function (y, X, intercept=TRUE) {
  if (intercept) X <- cbind(X, 1)
  solve(t(X)%*%X) %*% t(X)%*%y # solve for beta
}
```

We used the following data.

```{r}
data(iris)
x1 <- iris$Petal.Width
x2 <- iris$Sepal.Length
y  <- iris$Petal.Length
```

This allowed us to estimate a linear model.

```{r}
X <- cbind(x1, x2)
ols(y = y, X = X)
```

Which includes the intercept, since the default value it `TRUE` (see function definition above),
we could estimate it without an intercept using.

```{r}
ols(y = y, X = X, intercept = FALSE)
```

Having revisited the above, we can continue with instumental variables.
Let's start with some simulated data.

```{r}
# this gives us the same random numbers
set.seed(123)

library(MASS)

# we are really generating x* and c and using a common variance
xStarAndC <- mvrnorm(1000, c(20, 15), matrix(c(1, 0.5, 0.5, 1), 2, 2))
xStar <- xStarAndC[, 1]
c <- xStarAndC[, 2]
z <- rnorm(1000)
x <- xStar + z

# using 1 makes it easy to estimate how 'wrong' an estimator is and toss
# some noise on y
y <- 1 + x + c + rnorm(1000, 0, 0.5)

# test
lm(y ~ x + c)
```

We first need to obtain our first stage estimate (putting the whole function between parentheses allows us to both write it to the object `s1` and print it.

```{r}
( s1 <- ols(y = x, X = z) )
```

We can now obtain the predicted (fitted) values

```{r}
Xhat <- s1[1]*z + s1[2]
```

Using these fitted values, we can finally estimate our second stage.

```{r}
ols(y = y, X = Xhat)
```

Now compare this to the results using the `AER` (Applied Econometric Regressions) package.

```{r}
library(AER)
ivreg(y ~ x | z)
```

We can also do this using `R`'s built in `lm` function.

```{r}
# first stage
s1 <- lm(x ~ z)

# estimate second stage using fitted values (Xhat)
lm(y ~ s1$fitted.values)
```

As an intermediate form, we can  manually calculate `Xhat` (`fitted.values`) and estimate using that.

```{r}
# manually obtain fitted values
Xhat <- s1$coefficients[2]*z + s1$coefficients[1]

# estimate second stage using Xhat
lm(y ~ Xhat)
```

Note that if you estimate a TSLS using the `lm` function,
that you can **only** use the coefficients,
the error terms will be **wrong**. 
